[
    {
        "id": "4ec0a7f75863202f",
        "type": "tab",
        "label": "REPORT_UPDATE",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "b89c21b9c5642159",
        "type": "link in",
        "z": "4ec0a7f75863202f",
        "name": "REPORT_IN",
        "links": [
            "bb5af27275e2ee33"
        ],
        "x": 75,
        "y": 220,
        "wires": [
            [
                "d45672f67dbbab27",
                "24687e8eaa6997ca",
                "ac7df2e2275af626"
            ]
        ]
    },
    {
        "id": "83e451fc86ef20c7",
        "type": "function",
        "z": "4ec0a7f75863202f",
        "name": "SIMULATE REPORT",
        "func": "// Creating the payload based on the provided structure\nlet payload = {\n    \"settings\": {\n        \"id\": 4,\n        \"report_id\": 34300381,\n        \"standard\": \"IEC_62040_1\",\n        \"ups_model\": \"UVA-123\",\n        \"client_name\": \"Walton\",\n        \"brand_name\": \"Walton\",\n        \"test_engineer_name\": \"Engr Atik\",\n        \"test_approval_name\": \"Engr Jhon\",\n        \"spec_id\": 4\n    },\n    \"test_name\": \"BackupTest\",\n    \"test_description\": \"Backup Test Report\",\n    \"measurements\": [\n        {\n            \"m_unique_id\": 6804338082,\n            \"time_stamp\": 1735741904962,\n            \"name\": \"Measurement Backup test\",\n            \"mode\": \"NORMAL_MODE\",\n            \"phase_name\": \"Phase A\",\n            \"load_type\": \"LINEAR\",\n            \"step_id\": 0,\n            \"load_percentage\": 6,\n            \"power_measures\": [\n                {\n                    \"type\": \"UPS_INPUT\",\n                    \"voltage\": 0,\n                    \"current\": 0,\n                    \"power\": 0,\n                    \"energy\": 0,\n                    \"pf\": 0,\n                    \"frequency\": 0\n                },\n                {\n                    \"type\": \"UPS_OUTPUT\",\n                    \"voltage\": 0,\n                    \"current\": 0,\n                    \"power\": 0,\n                    \"energy\": 0,\n                    \"pf\": 0,\n                    \"frequency\": 0\n                }\n            ],\n            \"steady_state_voltage_tol\": 0,\n            \"voltage_dc_component\": 0,\n            \"load_pf_deviation\": 0,\n            \"switch_time_ms\": 0,\n            \"run_interval_sec\": 10,\n            \"backup_time_sec\": 0,\n            \"overload_time_sec\": 0,\n            \"temperature_1\": 0,\n            \"temperature_2\": 0\n        },\n        {\n            \"m_unique_id\": 7908496175,\n            \"time_stamp\": 1735741923950,\n            \"name\": \"Measurement Backup test\",\n            \"mode\": \"NORMAL_MODE\",\n            \"phase_name\": \"Phase A\",\n            \"load_type\": \"LINEAR\",\n            \"step_id\": 0,\n            \"load_percentage\": 6,\n            \"power_measures\": [\n                {\n                    \"type\": \"UPS_INPUT\",\n                    \"voltage\": 0,\n                    \"current\": 0,\n                    \"power\": 0,\n                    \"energy\": 0,\n                    \"pf\": 0,\n                    \"frequency\": 0\n                },\n                {\n                    \"type\": \"UPS_OUTPUT\",\n                    \"voltage\": 0,\n                    \"current\": 0,\n                    \"power\": 0,\n                    \"energy\": 0,\n                    \"pf\": 0,\n                    \"frequency\": 0\n                }\n            ],\n            \"steady_state_voltage_tol\": 0,\n            \"voltage_dc_component\": 0,\n            \"load_pf_deviation\": 0,\n            \"switch_time_ms\": 0,\n            \"run_interval_sec\": 10,\n            \"backup_time_sec\": 0,\n            \"overload_time_sec\": 0,\n            \"temperature_1\": 0,\n            \"temperature_2\": 0\n        }\n    ],\n    \"test_result\": \"USER_OBSERVATION\"\n};\n\n// Output the payload for the next node in the flow\nmsg.payload = payload;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 280,
        "y": 40,
        "wires": [
            [
                "d45672f67dbbab27",
                "d835063f835b621d",
                "ac7df2e2275af626",
                "24687e8eaa6997ca"
            ]
        ]
    },
    {
        "id": "d45672f67dbbab27",
        "type": "function",
        "z": "4ec0a7f75863202f",
        "name": "SORT_REPORT",
        "func": "let payload = msg.payload;\n\n// Extract Settings Object\nlet settings = payload.settings;\n\n// Extract Measurements Array\nlet measurements = payload.measurements;\n\n// Extract Remaining Data\nlet { settings: _, measurements: __, ...otherObjects } = payload;\n\n// Extract all measurement IDs\nlet measurement_ids = measurements.map(measurement => measurement.m_unique_id);\n\n// Store the measurement_ids array in flow context\nflow.set(\"measurement_ids\", measurement_ids);\n\n// Prepare Outputs\nconst output = [\n    { payload: settings },         // Output 1: Settings Object\n    { payload: measurements },     // Output 2: Measurements Array\n    { payload: otherObjects }      // Output 3: Other Remaining Objects\n];\n\n// Send Result\nreturn output;\n\n",
        "outputs": 3,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 330,
        "y": 180,
        "wires": [
            [
                "0086034d5d1b5475",
                "754de0d72315e873"
            ],
            [
                "172c261c1913ab30"
            ],
            [
                "fc922076f1ffa401"
            ]
        ]
    },
    {
        "id": "0086034d5d1b5475",
        "type": "debug",
        "z": "4ec0a7f75863202f",
        "name": "settings",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 580,
        "y": 140,
        "wires": []
    },
    {
        "id": "172c261c1913ab30",
        "type": "debug",
        "z": "4ec0a7f75863202f",
        "name": "measurements",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 600,
        "y": 180,
        "wires": []
    },
    {
        "id": "fc922076f1ffa401",
        "type": "debug",
        "z": "4ec0a7f75863202f",
        "name": "others",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 570,
        "y": 220,
        "wires": []
    },
    {
        "id": "112848acd093c60f",
        "type": "inject",
        "z": "4ec0a7f75863202f",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 140,
        "y": 140,
        "wires": [
            [
                "83e451fc86ef20c7"
            ]
        ]
    },
    {
        "id": "d835063f835b621d",
        "type": "debug",
        "z": "4ec0a7f75863202f",
        "name": "debug 8",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 580,
        "y": 80,
        "wires": []
    },
    {
        "id": "ac7df2e2275af626",
        "type": "function",
        "z": "4ec0a7f75863202f",
        "name": "PROCESS MEASUREMENTS",
        "func": "// // Helper function for delaying execution\n// function delay(ms) {\n//     return new Promise(resolve => setTimeout(resolve, ms));\n// }\n\n// // Asynchronous function to process measurements\n// async function processMeasurements(measurements, send, done) {\n//     for (let measurement of measurements) {\n//         const measurementId = measurement.m_unique_id;\n//         const powerMeasures = measurement.power_measures.map(pm => ({\n//             ...pm,\n//             measurement_id: measurementId\n//         }));\n\n//         // Create rest_measurement by excluding the power_measures field\n//         const { power_measures, ...restMeasurement } = measurement;\n\n//         // Iterate over power measures and send alternately with rest_measurement\n//         for (let powerMeasure of powerMeasures) {\n//             // Send power measure first (Output 1)\n//             send([ { payload: powerMeasure }, null ]);\n//             await delay(1000); // 1-second delay\n\n//             // Send the rest of the measurement (Output 2)\n//             send([ null, { payload: restMeasurement } ]);\n//             await delay(1000); // 1-second delay\n//         }\n//     }\n//     done(); // Indicate the function has completed\n// }\n\n// // Main Function Logic\n// let payload = msg.payload;\n\n// // Ensure the input contains measurements\n// if (!payload.measurements || !Array.isArray(payload.measurements)) {\n//     node.error(\"Invalid input: 'measurements' must be an array.\", msg);\n//     return null;\n// }\n\n// // Start asynchronous processing\n// processMeasurements(payload.measurements, node.send, () => node.done());\n\n// // Return null as the function sends messages asynchronously\n// return null;\n// Helper function for delaying execution\nfunction delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// Asynchronous function to process measurements\nasync function processMeasurements(measurements, send, done) {\n    for (let measurement of measurements) {\n        const measurementId = measurement.m_unique_id;\n        const powerMeasures = measurement.power_measures.map(pm => ({\n            ...pm,\n            measurement_id: measurementId\n        }));\n\n        // Create rest_measurement by excluding the power_measures field\n        const { power_measures, ...restMeasurement } = measurement;\n\n        // Iterate over power measures and send alternately with rest_measurement\n        for (let powerMeasure of powerMeasures) {\n            // Send power measure first (Output 1)\n            send([ \n                { payload: powerMeasure }, \n                null, \n                { payload: false } // Default value for Output 3\n            ]);\n            await delay(1000); // 1-second delay\n\n            // Send the rest of the measurement (Output 2)\n            send([ \n                null, \n                { payload: restMeasurement }, \n                { payload: false } // Default value for Output 3\n            ]);\n            await delay(1000); // 1-second delay\n        }\n    }\n\n    // Send a payload `true` to Output 3 when all processing is done\n    send([ null, null, { payload: true } ]);\n    done(); // Indicate the function has completed\n}\n\n// Main Function Logic\nlet payload = msg.payload;\n\n// Ensure the input contains measurements\nif (!payload.measurements || !Array.isArray(payload.measurements)) {\n    node.error(\"Invalid input: 'measurements' must be an array.\", msg);\n    return null;\n}\n\n// Start asynchronous processing\nprocessMeasurements(payload.measurements, node.send, () => node.done());\n\n// Return null as the function sends messages asynchronously\nreturn null;\n",
        "outputs": 3,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 210,
        "y": 340,
        "wires": [
            [
                "24a1009b7bdba82f"
            ],
            [
                "5105a5689c31d313",
                "ca8987ad0fbb0784"
            ],
            [
                "bd7f18585a56529d",
                "32965671a41e135c",
                "bc8e9479fde69e7d"
            ]
        ]
    },
    {
        "id": "24a1009b7bdba82f",
        "type": "debug",
        "z": "4ec0a7f75863202f",
        "name": "power data",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 550,
        "y": 280,
        "wires": []
    },
    {
        "id": "20450f4f7a43a947",
        "type": "function",
        "z": "4ec0a7f75863202f",
        "name": "insert _power_measures",
        "func": "// Ensure msg.payload contains the necessary data\nif (!msg.payload || typeof msg.payload !== \"object\") {\n    node.error(\"Invalid input: msg.payload must be an object.\");\n    return null;\n}\n\n// Extract powerMeasure object from msg.payload\nvar powerMeasure = msg.payload;\n\n// Validate required fields\nif (\n    powerMeasure.type === undefined ||\n    powerMeasure.voltage === undefined ||\n    powerMeasure.current === undefined ||\n    powerMeasure.power === undefined ||\n    powerMeasure.energy === undefined ||\n    powerMeasure.pf === undefined ||\n    powerMeasure.frequency === undefined ||\n    powerMeasure.measurement_id === undefined\n) {\n    node.error(\"Invalid input: msg.payload must contain all required fields.\");\n    return null;\n}\n\n// Construct the SQL query\nvar topic = `INSERT INTO PowerMeasure (type, voltage, current, power, energy, pf, frequency, measurement_id) \nVALUES (${powerMeasure.type}, ${powerMeasure.voltage}, ${powerMeasure.current}, ${powerMeasure.power}, \n${powerMeasure.energy}, ${powerMeasure.pf}, ${powerMeasure.frequency}, ${powerMeasure.measurement_id});`;\n\n// Return the query to be executed by the SQLite node\nreturn { topic: topic };\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 150,
        "y": 680,
        "wires": [
            [
                "519b0cfe351f15ce"
            ]
        ]
    },
    {
        "id": "b0fe93bafaeabdf8",
        "type": "debug",
        "z": "4ec0a7f75863202f",
        "name": "debug 12",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1200,
        "y": 640,
        "wires": []
    },
    {
        "id": "519b0cfe351f15ce",
        "type": "sqlite",
        "z": "4ec0a7f75863202f",
        "mydb": "0d4c44b815a8faab",
        "sqlquery": "msg.topic",
        "sql": "",
        "name": "MAIN_DB",
        "x": 360,
        "y": 680,
        "wires": [
            [
                "712512ae60b1cdc9"
            ]
        ]
    },
    {
        "id": "712512ae60b1cdc9",
        "type": "function",
        "z": "4ec0a7f75863202f",
        "name": "get powermeasure id",
        "func": "msg.topic=\"SELECT last_insert_rowid()\";\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 540,
        "y": 680,
        "wires": [
            [
                "16e508bdf889111c"
            ]
        ]
    },
    {
        "id": "16e508bdf889111c",
        "type": "sqlite",
        "z": "4ec0a7f75863202f",
        "mydb": "0d4c44b815a8faab",
        "sqlquery": "msg.topic",
        "sql": "",
        "name": "MAIN_DB",
        "x": 740,
        "y": 660,
        "wires": [
            [
                "72fb27e46012366a"
            ]
        ]
    },
    {
        "id": "72fb27e46012366a",
        "type": "function",
        "z": "4ec0a7f75863202f",
        "name": "save power measure id",
        "func": "// Ensure msg.payload contains the ID from the query result\nif (!msg.payload || !msg.payload[0] || !msg.payload[0]['last_insert_rowid()']) {\n    node.error(\"Invalid input: msg.payload must contain the result of last_insert_rowid().\");\n    return null;\n}\n\n// Extract the last inserted row ID\nlet lastInsertId = msg.payload[0]['last_insert_rowid()'];\n\n// Retrieve the existing array from flow context or initialize it\nlet allPowerMeasureIds = flow.get(\"all_power_measure_id\") || [];\n\n// Add the new ID to the array\nallPowerMeasureIds.push(lastInsertId);\n\n// Save the updated array back to the flow context\nflow.set(\"all_power_measure_id\", allPowerMeasureIds);\n\n// Log the updated array for debugging (optional)\nnode.warn(`Updated all_power_measure_id: ${JSON.stringify(allPowerMeasureIds)}`);\n\n// Pass through the message for further processing\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 990,
        "y": 700,
        "wires": [
            [
                "b0fe93bafaeabdf8"
            ]
        ]
    },
    {
        "id": "5105a5689c31d313",
        "type": "debug",
        "z": "4ec0a7f75863202f",
        "name": "rest",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 590,
        "y": 320,
        "wires": []
    },
    {
        "id": "24687e8eaa6997ca",
        "type": "function",
        "z": "4ec0a7f75863202f",
        "name": "SAVE LINKS",
        "func": "// Get the existing report-m_unique_id mapping from flow context\nlet reportLinks = flow.get(\"reportLinks\") || {};\n\n// Ensure `report_id` is always a number\nconst reportId = Number(msg.payload.settings.report_id);\nif (isNaN(reportId)) {\n    node.error(`Invalid report_id in Function 1: ${msg.payload.settings.report_id}`);\n    return null;\n}\n\n// Extract m_unique_id values\nconst measurementIds = msg.payload.measurements.map(measurement => measurement.m_unique_id);\n\n// Add the report_id and associated m_unique_id values\nif (!reportLinks[reportId]) {\n    reportLinks[reportId] = []; // Initialize if not present\n}\n\n// Avoid duplicates by combining arrays and using Set\nreportLinks[reportId] = Array.from(new Set([...reportLinks[reportId], ...measurementIds]));\n\n// Save updated reportLinks in flow context\nflow.set(\"reportLinks\", reportLinks);\n\n// Debug: Log the current state of the flow context\nnode.warn(`Report Links Updated (Function 1): ${JSON.stringify(reportLinks, null, 2)}`);\n\nreturn msg;\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 330,
        "y": 240,
        "wires": [
            [
                "f324b50360a0a3ef"
            ]
        ]
    },
    {
        "id": "f324b50360a0a3ef",
        "type": "debug",
        "z": "4ec0a7f75863202f",
        "name": "report link",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 840,
        "y": 240,
        "wires": []
    },
    {
        "id": "ca8987ad0fbb0784",
        "type": "function",
        "z": "4ec0a7f75863202f",
        "name": "Measurement with report  id",
        "func": "// // Retrieve the reportLinks object from flow context\nlet reportLinks = flow.get(\"reportLinks\") || {};\nnode.warn(`Function 2: Retrieved reportLinks = ${JSON.stringify(reportLinks, null, 2)}`);\n\n// Extract the new measurement from the message payload\nlet new_measurement = msg.payload;\n\n// Validate the measurement ID\nconst measurementId = new_measurement.m_unique_id;\nif (!measurementId) {\n    node.error(\"Invalid measurement_id: undefined\", msg);\n    return null;\n}\n\n// Find the report_id for the given measurementId\nlet foundReportId = null;\nfor (const [id, measurementIds] of Object.entries(reportLinks)) {\n    if (measurementIds.includes(measurementId)) {\n        foundReportId = Number(id); // Ensure report_id is returned as a number\n        break;\n    }\n}\n\n// Update the measurement with the found report_id or log an error\nif (foundReportId) {\n    new_measurement.report_id = foundReportId;\n    msg.payload.report_id = foundReportId;\n    node.warn(`Measurement ID ${measurementId} belongs to Report ID ${foundReportId}`);\n} else {\n    msg.payload.error = `Measurement ID ${measurementId} not found in any report.`;\n    node.warn(`Measurement ID ${measurementId} not found.`);\n}\n\n// Retrieve or initialize the all_measurements array in the flow context\nlet all_measurements = flow.get(\"all_measurements\") || [];\n\n// Check for duplicates before adding the new measurement\nlet isDuplicate = all_measurements.some(\n    measurement =>\n        measurement.m_unique_id === new_measurement.m_unique_id &&\n        measurement.report_id === new_measurement.report_id\n);\n\nif (!isDuplicate) {\n    all_measurements.push(new_measurement);\n    flow.set(\"all_measurements\", all_measurements);\n    node.warn(`Added new measurement: ${JSON.stringify(new_measurement, null, 2)}`);\n} else {\n    node.warn(`Duplicate measurement detected. Skipping addition: ${JSON.stringify(new_measurement, null, 2)}`);\n}\n\n// Return the message object\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 300,
        "y": 420,
        "wires": [
            [
                "f6b97959bb3614c9"
            ]
        ]
    },
    {
        "id": "f86ffbc386084a89",
        "type": "debug",
        "z": "4ec0a7f75863202f",
        "name": "report id",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 340,
        "y": 620,
        "wires": []
    },
    {
        "id": "18826b373af39421",
        "type": "function",
        "z": "4ec0a7f75863202f",
        "name": "INSERT measurement",
        "func": "// Ensure msg.payload contains the necessary data\nif (!msg.payload || typeof msg.payload !== \"object\") {\n    node.error(\"Invalid input: msg.payload must be an object.\");\n    return null;\n}\n\n// Extract measurement object from msg.payload\nvar measurement = msg.payload;\n\n// Validate required fields\nif (\n    measurement.m_unique_id === undefined ||\n    measurement.time_stamp === undefined ||\n    measurement.name === undefined ||\n    measurement.report_id === undefined\n) {\n    node.error(\"Invalid input: msg.payload must contain all required fields (m_unique_id, time_stamp, name, report_id).\");\n    return null;\n}\n\n// Escape string values to prevent SQL injection\nfunction escapeString(str) {\n    return str.replace(/'/g, \"''\");\n}\n\n// Construct the SQL query with proper handling of null values\nvar topic = `\n    INSERT INTO Measurement (\n        m_unique_id, timestamp, name, mode, phase_name, load_type, step_id, \n        load_percentage, steady_state_voltage_tol, voltage_dc_component, \n        load_pf_deviation, switch_time_ms, run_interval_sec, backup_time_sec, \n        overload_time_sec, temperature_1, temperature_2, test_report_id\n    ) VALUES (\n        ${measurement.m_unique_id}, \n        datetime(${measurement.time_stamp} / 1000, 'unixepoch'), \n        '${escapeString(measurement.name)}', \n        ${measurement.mode ? `'${escapeString(measurement.mode)}'` : 'NULL'}, \n        ${measurement.phase_name ? `'${escapeString(measurement.phase_name)}'` : 'NULL'}, \n        ${measurement.load_type ? `'${escapeString(measurement.load_type)}'` : 'NULL'}, \n        ${measurement.step_id !== undefined ? measurement.step_id : 'NULL'}, \n        ${measurement.load_percentage !== undefined ? measurement.load_percentage : 'NULL'}, \n        ${measurement.steady_state_voltage_tol !== undefined ? measurement.steady_state_voltage_tol : 'NULL'}, \n        ${measurement.voltage_dc_component !== undefined ? measurement.voltage_dc_component : 'NULL'}, \n        ${measurement.load_pf_deviation !== undefined ? measurement.load_pf_deviation : 'NULL'}, \n        ${measurement.switch_time_ms !== undefined ? measurement.switch_time_ms : 'NULL'}, \n        ${measurement.run_interval_sec !== undefined ? measurement.run_interval_sec : 'NULL'}, \n        ${measurement.backup_time_sec !== undefined ? measurement.backup_time_sec : 'NULL'}, \n        ${measurement.overload_time_sec !== undefined ? measurement.overload_time_sec : 'NULL'}, \n        ${measurement.temperature_1 !== undefined ? measurement.temperature_1 : 'NULL'}, \n        ${measurement.temperature_2 !== undefined ? measurement.temperature_2 : 'NULL'}, \n        ${measurement.report_id}\n    );\n`;\n\n// Return the query to be executed by the SQLite node\nreturn { topic: topic };\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 460,
        "y": 560,
        "wires": [
            [
                "5f1f3198bcee0d63"
            ]
        ]
    },
    {
        "id": "5f1f3198bcee0d63",
        "type": "sqlite",
        "z": "4ec0a7f75863202f",
        "mydb": "0d4c44b815a8faab",
        "sqlquery": "msg.topic",
        "sql": "",
        "name": "MAIN_DB",
        "x": 660,
        "y": 560,
        "wires": [
            [
                "0e1b7fd7829d8533"
            ]
        ]
    },
    {
        "id": "0e1b7fd7829d8533",
        "type": "function",
        "z": "4ec0a7f75863202f",
        "name": "get measurement id",
        "func": "msg.topic=\"SELECT last_insert_rowid()\";\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 840,
        "y": 560,
        "wires": [
            [
                "cb6be12251a7102f"
            ]
        ]
    },
    {
        "id": "cb6be12251a7102f",
        "type": "sqlite",
        "z": "4ec0a7f75863202f",
        "mydb": "0d4c44b815a8faab",
        "sqlquery": "msg.topic",
        "sql": "",
        "name": "MAIN_DB",
        "x": 1020,
        "y": 560,
        "wires": [
            [
                "1a31d7bd6a90d2d8"
            ]
        ]
    },
    {
        "id": "1a31d7bd6a90d2d8",
        "type": "function",
        "z": "4ec0a7f75863202f",
        "name": "save measurement id",
        "func": "// Ensure msg.payload contains the ID from the query result\nif (!msg.payload || !msg.payload[0] || !msg.payload[0]['last_insert_rowid()']) {\n    node.error(\"Invalid input: msg.payload must contain the result of last_insert_rowid().\");\n    return null;\n}\n\n// Extract the last inserted row ID\nlet lastInsertId = msg.payload[0]['last_insert_rowid()'];\n\n// Retrieve the existing array from flow context or initialize it\nlet allMeasurementIds = flow.get(\"all_measurement_id\") || [];\n\n// Add the new ID to the array\nallMeasurementIds.push(lastInsertId);\n\n// Save the updated array back to the flow context\nflow.set(\"all_measurement_id\", allMeasurementIds);\n\n// Log the updated array for debugging (optional)\nnode.warn(`Updated all_measurement_id: ${JSON.stringify(allMeasurementIds)}`);\n\n// Pass through the message for further processing\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 140,
        "y": 620,
        "wires": [
            [
                "f86ffbc386084a89"
            ]
        ]
    },
    {
        "id": "f6b97959bb3614c9",
        "type": "debug",
        "z": "4ec0a7f75863202f",
        "name": "debug 13",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 520,
        "y": 440,
        "wires": []
    },
    {
        "id": "bd7f18585a56529d",
        "type": "debug",
        "z": "4ec0a7f75863202f",
        "name": "PROCESS_COMPLETE",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 630,
        "y": 360,
        "wires": []
    },
    {
        "id": "754de0d72315e873",
        "type": "function",
        "z": "4ec0a7f75863202f",
        "name": "SET_LATEST_REPORT_ID",
        "func": "let settings=msg.payload;\nflow.set(\"latest_report_id\",settings.report_id||0);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 820,
        "y": 80,
        "wires": [
            []
        ]
    },
    {
        "id": "7126aec203523eaf",
        "type": "change",
        "z": "4ec0a7f75863202f",
        "name": "",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "latest_report_id",
                "tot": "flow"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 200,
        "y": 480,
        "wires": [
            [
                "8234f43a6332c074",
                "d56511342a6aa80d"
            ]
        ]
    },
    {
        "id": "8234f43a6332c074",
        "type": "debug",
        "z": "4ec0a7f75863202f",
        "name": "latest_report_id",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 520,
        "y": 480,
        "wires": []
    },
    {
        "id": "32965671a41e135c",
        "type": "switch",
        "z": "4ec0a7f75863202f",
        "name": "",
        "property": "payload",
        "propertyType": "msg",
        "rules": [
            {
                "t": "false"
            },
            {
                "t": "true"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 70,
        "y": 440,
        "wires": [
            [],
            [
                "7126aec203523eaf"
            ]
        ]
    },
    {
        "id": "d56511342a6aa80d",
        "type": "function",
        "z": "4ec0a7f75863202f",
        "name": "FETCH MEASUREMENTS",
        "func": "// Helper function for delaying execution\nfunction delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// Retrieve all measurements from flow context\nlet all_measurements = flow.get(\"all_measurements\") || [];\nnode.warn(`Retrieved all_measurements: ${JSON.stringify(all_measurements, null, 2)}`);\n\n// Get the desired report_id from the incoming message\nlet reportId = msg.payload;\nif (reportId === undefined || reportId === null) {\n    node.error(\"Invalid report_id: undefined or null\", msg);\n    return null;\n}\n\n// Filter measurements for the given report_id\nlet filteredMeasurements = all_measurements.filter(m => m.report_id === reportId);\n\nif (filteredMeasurements.length === 0) {\n    node.warn(`No measurements found for report_id: ${reportId}`);\n    return null;\n}\n\n// Async function to send measurements one by one\nasync function sendMeasurements(measurements, send, done) {\n    for (let measurement of measurements) {\n        send({ payload: measurement }); // Send each measurement\n        await delay(1000); // 1-second delay between each message\n    }\n    done(); // Indicate processing is complete\n}\n\n// Start sending measurements asynchronously\nsendMeasurements(filteredMeasurements, node.send, () => node.done());\n\n// Return null as the function sends messages asynchronously\nreturn null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 200,
        "y": 560,
        "wires": [
            [
                "18826b373af39421"
            ]
        ]
    },
    {
        "id": "bc8e9479fde69e7d",
        "type": "ui-led",
        "z": "4ec0a7f75863202f",
        "name": "DATA Processed",
        "group": "ac18f679c10f1fd0",
        "order": 3,
        "width": 0,
        "height": 0,
        "label": "DATA Processed",
        "labelPlacement": "left",
        "labelAlignment": "left",
        "states": [
            {
                "value": "false",
                "valueType": "bool",
                "color": "#ff0000"
            },
            {
                "value": "true",
                "valueType": "bool",
                "color": "#00ff00"
            }
        ],
        "allowColorForValueInMessage": false,
        "shape": "circle",
        "showBorder": true,
        "showGlow": true,
        "x": 630,
        "y": 400,
        "wires": []
    },
    {
        "id": "0d4c44b815a8faab",
        "type": "sqlitedb",
        "db": "D:\\_0_DEV_SOFTWARE\\PIO_ESPIDF\\UPS_TESTER_PROJECT\\powerGuard\\db\\test_reports.db",
        "mode": "RWC"
    },
    {
        "id": "ac18f679c10f1fd0",
        "type": "ui-group",
        "name": "UPS_STATUS",
        "page": "7d0f53039d1540b1",
        "width": 3,
        "height": "1",
        "order": 1,
        "showTitle": true,
        "className": "",
        "visible": "true",
        "disabled": "false",
        "groupType": "default"
    },
    {
        "id": "7d0f53039d1540b1",
        "type": "ui-page",
        "name": "BACKUP_TEST",
        "ui": "6bb6879aa70631ea",
        "path": "/backup_test",
        "icon": "battery-clock",
        "layout": "grid",
        "theme": "f51f9a07212ff54b",
        "breakpoints": [
            {
                "name": "Default",
                "px": "0",
                "cols": "3"
            },
            {
                "name": "Tablet",
                "px": "576",
                "cols": "6"
            },
            {
                "name": "Small Desktop",
                "px": "768",
                "cols": "9"
            },
            {
                "name": "Desktop",
                "px": "1024",
                "cols": "12"
            }
        ],
        "order": 2,
        "className": "",
        "visible": "true",
        "disabled": "false"
    },
    {
        "id": "6bb6879aa70631ea",
        "type": "ui-base",
        "name": "UPS Tester",
        "path": "/dashboard",
        "appIcon": "",
        "includeClientData": true,
        "acceptsClientConfig": [
            "ui-notification",
            "ui-control"
        ],
        "showPathInSidebar": false,
        "showPageTitle": true,
        "navigationStyle": "default",
        "titleBarStyle": "default",
        "showReconnectNotification": true,
        "notificationDisplayTime": "1",
        "showDisconnectNotification": true
    },
    {
        "id": "f51f9a07212ff54b",
        "type": "ui-theme",
        "name": "Default Theme",
        "colors": {
            "surface": "#d1479f",
            "primary": "#0094ce",
            "bgPage": "#ededed",
            "groupBg": "#ffffff",
            "groupOutline": "#cccccc"
        },
        "sizes": {
            "density": "default",
            "pagePadding": "12px",
            "groupGap": "12px",
            "groupBorderRadius": "4px",
            "widgetGap": "12px"
        }
    }
]