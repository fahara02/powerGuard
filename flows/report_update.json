[
    {
        "id": "4ec0a7f75863202f",
        "type": "tab",
        "label": "REPORT_UPDATE",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "b89c21b9c5642159",
        "type": "link in",
        "z": "4ec0a7f75863202f",
        "name": "REPORT_IN",
        "links": [
            "bb5af27275e2ee33"
        ],
        "x": 35,
        "y": 120,
        "wires": [
            [
                "d45672f67dbbab27",
                "24687e8eaa6997ca",
                "ac7df2e2275af626"
            ]
        ]
    },
    {
        "id": "83e451fc86ef20c7",
        "type": "function",
        "z": "4ec0a7f75863202f",
        "name": "SIMULATE REPORT",
        "func": "// Creating the payload based on the provided structure\nlet payload = {\n    \"settings\": {\n        \"id\": 4,\n        \"report_id\": 34300381,\n        \"standard\": \"IEC_62040_1\",\n        \"ups_model\": \"UVA-123\",\n        \"client_name\": \"Walton\",\n        \"brand_name\": \"Walton\",\n        \"test_engineer_name\": \"Engr Atik\",\n        \"test_approval_name\": \"Engr Jhon\",\n        \"spec_id\": 4\n    },\n    \"test_name\": \"BackupTest\",\n    \"test_description\": \"Backup Test Report\",\n    \"measurements\": [\n        {\n            \"m_unique_id\": 6804338082,\n            \"time_stamp\": 1735741904962,\n            \"name\": \"Measurement Backup test\",\n            \"mode\": \"NORMAL_MODE\",\n            \"phase_name\": \"Phase A\",\n            \"load_type\": \"LINEAR\",\n            \"step_id\": 0,\n            \"load_percentage\": 6,\n            \"power_measures\": [\n                {\n                    \"type\": \"UPS_INPUT\",\n                    \"voltage\": 0,\n                    \"current\": 0,\n                    \"power\": 0,\n                    \"energy\": 0,\n                    \"pf\": 0,\n                    \"frequency\": 0\n                },\n                {\n                    \"type\": \"UPS_OUTPUT\",\n                    \"voltage\": 0,\n                    \"current\": 0,\n                    \"power\": 0,\n                    \"energy\": 0,\n                    \"pf\": 0,\n                    \"frequency\": 0\n                }\n            ],\n            \"steady_state_voltage_tol\": 0,\n            \"voltage_dc_component\": 0,\n            \"load_pf_deviation\": 0,\n            \"switch_time_ms\": 0,\n            \"run_interval_sec\": 10,\n            \"backup_time_sec\": 0,\n            \"overload_time_sec\": 0,\n            \"temperature_1\": 0,\n            \"temperature_2\": 0\n        },\n        {\n            \"m_unique_id\": 7908496175,\n            \"time_stamp\": 1735741923950,\n            \"name\": \"Measurement Backup test\",\n            \"mode\": \"NORMAL_MODE\",\n            \"phase_name\": \"Phase A\",\n            \"load_type\": \"LINEAR\",\n            \"step_id\": 0,\n            \"load_percentage\": 6,\n            \"power_measures\": [\n                {\n                    \"type\": \"UPS_INPUT\",\n                    \"voltage\": 0,\n                    \"current\": 0,\n                    \"power\": 0,\n                    \"energy\": 0,\n                    \"pf\": 0,\n                    \"frequency\": 0\n                },\n                {\n                    \"type\": \"UPS_OUTPUT\",\n                    \"voltage\": 0,\n                    \"current\": 0,\n                    \"power\": 0,\n                    \"energy\": 0,\n                    \"pf\": 0,\n                    \"frequency\": 0\n                }\n            ],\n            \"steady_state_voltage_tol\": 0,\n            \"voltage_dc_component\": 0,\n            \"load_pf_deviation\": 0,\n            \"switch_time_ms\": 0,\n            \"run_interval_sec\": 10,\n            \"backup_time_sec\": 0,\n            \"overload_time_sec\": 0,\n            \"temperature_1\": 0,\n            \"temperature_2\": 0\n        }\n    ],\n    \"test_result\": \"USER_OBSERVATION\"\n};\n\n// Output the payload for the next node in the flow\nmsg.payload = payload;\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 440,
        "y": 40,
        "wires": [
            [
                "d45672f67dbbab27",
                "ac7df2e2275af626",
                "24687e8eaa6997ca"
            ]
        ]
    },
    {
        "id": "d45672f67dbbab27",
        "type": "function",
        "z": "4ec0a7f75863202f",
        "name": "SORT_REPORT",
        "func": "let payload = msg.payload;\n\n// Extract Measurements Array\nlet measurements = payload.measurements;\n\n// Extract Remaining Data and Combine Settings with Other Data\nlet { settings, measurements: _, ...otherData } = payload;\nlet rest_report = { settings, ...otherData };\n\n// Extract all measurement IDs\nlet measurement_ids = measurements.map(measurement => measurement.m_unique_id);\n\n// Store the measurement_ids array in flow context\nflow.set(\"measurement_ids\", measurement_ids);\n\n// Prepare Outputs\nconst output = [\n    { payload: measurements }, // Output 1: Measurements Array\n    { payload: rest_report }   // Output 2: Combined Rest Report\n];\n\n// Send Result\nreturn output;\n\n\n",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 290,
        "y": 120,
        "wires": [
            [
                "ed0573ddae590b22"
            ],
            [
                "754de0d72315e873",
                "ef1c0aa150a88ea5"
            ]
        ]
    },
    {
        "id": "112848acd093c60f",
        "type": "inject",
        "z": "4ec0a7f75863202f",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 240,
        "y": 40,
        "wires": [
            [
                "83e451fc86ef20c7"
            ]
        ]
    },
    {
        "id": "ac7df2e2275af626",
        "type": "function",
        "z": "4ec0a7f75863202f",
        "name": "PROCESS MEASUREMENTS",
        "func": "\nfunction delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n  const allPowerData = [];\n// Asynchronous function to process measurements\nasync function processMeasurements(measurements, send, done) {\n    // Array to hold all power data\n  \n\n    for (let measurement of measurements) {\n        const measurementId = measurement.m_unique_id;\n        const powerMeasures = measurement.power_measures.map(pm => ({\n            ...pm,\n            measurement_id: measurementId\n        }));\n\n        // Create rest_measurement by excluding the power_measures field\n        const { power_measures, ...restMeasurement } = measurement;\n\n        // Iterate over power measures\n        for (let powerMeasure of powerMeasures) {\n            // Add to aggregated power data\n            allPowerData.push(powerMeasure);\n\n            // Send power measure (Output 1)\n            send([\n                { payload: powerMeasure }, \n                null, \n                { payload: false } // Default value for Output 3\n            ]);\n            await delay(1000); // 1-second delay\n        }\n\n        // Send the rest of the measurement (Output 2) only once\n        send([\n            null, \n            { payload: restMeasurement }, \n            { payload: false } // Default value for Output 3\n        ]);\n        await delay(1000); // 1-second delay\n    }\n\n    // Store all power data in flow context\n    flow.set(\"all_power_data\", allPowerData);\n\n    // Send a payload `true` to Output 3 when all processing is done\n    send([null, null, { payload: true }]);\n    done(); // Indicate the function has completed\n}\n\n// Main Function Logic\nlet payload = msg.payload;\n\n// Ensure the input contains measurements\nif (!payload.measurements || !Array.isArray(payload.measurements)) {\n    node.error(\"Invalid input: 'measurements' must be an array.\", msg);\n    return null;\n}\n\n// Start asynchronous processing\nprocessMeasurements(payload.measurements, node.send, () => node.done());\n\n// Return null as the function sends messages asynchronously\nreturn null;\n",
        "outputs": 3,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 310,
        "y": 300,
        "wires": [
            [],
            [
                "ca8987ad0fbb0784"
            ],
            [
                "bc8e9479fde69e7d",
                "934392df93190d41"
            ]
        ]
    },
    {
        "id": "20450f4f7a43a947",
        "type": "function",
        "z": "4ec0a7f75863202f",
        "name": "insert _power_measures",
        "func": "// Ensure msg.payload contains the necessary data\nif (!msg.payload || typeof msg.payload !== \"object\") {\n    node.error(\"Invalid input: msg.payload must be an object.\");\n    return null;\n}\n\n// Extract powerMeasure object from msg.payload\nvar powerMeasure = msg.payload;\n\n// Validate required fields\nif (\n    powerMeasure.type === undefined ||\n    powerMeasure.voltage === undefined ||\n    powerMeasure.current === undefined ||\n    powerMeasure.power === undefined ||\n    powerMeasure.energy === undefined ||\n    powerMeasure.pf === undefined ||\n    powerMeasure.frequency === undefined ||\n    powerMeasure.measurement_id === undefined\n) {\n    node.error(\"Invalid input: msg.payload must contain all required fields.\");\n    return null;\n}\n\n// Construct the SQL query\nvar topic = `\n    INSERT INTO PowerMeasure (type, voltage, current, power, energy, pf, frequency, measurement_id) \n    VALUES (\n        '${powerMeasure.type}', \n        ${powerMeasure.voltage}, \n        ${powerMeasure.current}, \n        ${powerMeasure.power}, \n        ${powerMeasure.energy}, \n        ${powerMeasure.pf}, \n        ${powerMeasure.frequency}, \n        ${powerMeasure.measurement_id}\n    );\n`;\n\n// Return the query to be executed by the SQLite node\nreturn { topic: topic };\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 310,
        "y": 840,
        "wires": [
            [
                "519b0cfe351f15ce"
            ]
        ]
    },
    {
        "id": "b0fe93bafaeabdf8",
        "type": "debug",
        "z": "4ec0a7f75863202f",
        "name": "debug 12",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1280,
        "y": 840,
        "wires": []
    },
    {
        "id": "519b0cfe351f15ce",
        "type": "sqlite",
        "z": "4ec0a7f75863202f",
        "mydb": "0d4c44b815a8faab",
        "sqlquery": "msg.topic",
        "sql": "",
        "name": "MAIN_DB",
        "x": 500,
        "y": 840,
        "wires": [
            [
                "712512ae60b1cdc9"
            ]
        ]
    },
    {
        "id": "712512ae60b1cdc9",
        "type": "function",
        "z": "4ec0a7f75863202f",
        "name": "get powermeasure id",
        "func": "msg.topic=\"SELECT last_insert_rowid()\";\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 680,
        "y": 840,
        "wires": [
            [
                "16e508bdf889111c"
            ]
        ]
    },
    {
        "id": "16e508bdf889111c",
        "type": "sqlite",
        "z": "4ec0a7f75863202f",
        "mydb": "0d4c44b815a8faab",
        "sqlquery": "msg.topic",
        "sql": "",
        "name": "MAIN_DB",
        "x": 860,
        "y": 840,
        "wires": [
            [
                "72fb27e46012366a"
            ]
        ]
    },
    {
        "id": "72fb27e46012366a",
        "type": "function",
        "z": "4ec0a7f75863202f",
        "name": "save power measure id",
        "func": "// Ensure msg.payload contains the ID from the query result\nif (!msg.payload || !msg.payload[0] || !msg.payload[0]['last_insert_rowid()']) {\n    node.error(\"Invalid input: msg.payload must contain the result of last_insert_rowid().\");\n    return null;\n}\n\n// Extract the last inserted row ID\nlet lastInsertId = msg.payload[0]['last_insert_rowid()'];\n\n// Retrieve the existing array from flow context or initialize it\nlet allPowerMeasureIds = flow.get(\"all_power_measure_id\") || [];\n\n// Add the new ID to the array\nallPowerMeasureIds.push(lastInsertId);\n\n// Save the updated array back to the flow context\nflow.set(\"all_power_measure_id\", allPowerMeasureIds);\n\n// Log the updated array for debugging (optional)\nnode.warn(`Updated all_power_measure_id: ${JSON.stringify(allPowerMeasureIds)}`);\n\n// Pass through the message for further processing\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1050,
        "y": 840,
        "wires": [
            [
                "b0fe93bafaeabdf8",
                "a78403635e03631e"
            ]
        ]
    },
    {
        "id": "24687e8eaa6997ca",
        "type": "function",
        "z": "4ec0a7f75863202f",
        "name": "SAVE LINKS",
        "func": "// Get the existing report-m_unique_id mapping from flow context\nlet reportLinks = flow.get(\"reportLinks\") || {};\n\n// Ensure `report_id` is always a number\nconst subreport_id = Number(msg.payload.subreport_id);\nif (isNaN(subreport_id)) {\n    node.error(`Invalid subreport_id in Function 1: ${msg.payload.settings.report_id}`);\n    return null;\n}\n\n// Extract m_unique_id values\nconst measurementIds = msg.payload.measurements.map(measurement => measurement.m_unique_id);\n\n// Add the report_id and associated m_unique_id values\nif (!reportLinks[subreport_id]) {\n    reportLinks[subreport_id] = []; // Initialize if not present\n}\n\n// Avoid duplicates by combining arrays and using Set\nreportLinks[subreport_id] = Array.from(new Set([...reportLinks[subreport_id], ...measurementIds]));\n\n// Save updated reportLinks in flow context\nflow.set(\"reportLinks\", reportLinks);\n\n// Debug: Log the current state of the flow context\nnode.warn(`Report Links Updated (Function 1): ${JSON.stringify(reportLinks, null, 2)}`);\n\nreturn msg;\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 270,
        "y": 240,
        "wires": [
            [
                "f324b50360a0a3ef"
            ]
        ]
    },
    {
        "id": "f324b50360a0a3ef",
        "type": "debug",
        "z": "4ec0a7f75863202f",
        "name": "report link",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 840,
        "y": 240,
        "wires": []
    },
    {
        "id": "ca8987ad0fbb0784",
        "type": "function",
        "z": "4ec0a7f75863202f",
        "name": "SAVE Measurement with sub report  id",
        "func": "// // Retrieve the reportLinks object from flow context\nlet reportLinks = flow.get(\"reportLinks\") || {};\nnode.warn(`Function 2: Retrieved reportLinks = ${JSON.stringify(reportLinks, null, 2)}`);\n\n// Extract the new measurement from the message payload\nlet new_measurement = msg.payload;\n\n// Validate the measurement ID\nconst measurementId = new_measurement.m_unique_id;\nif (!measurementId) {\n    node.error(\"Invalid measurement_id: undefined\", msg);\n    return null;\n}\n\n// Find the report_id for the given measurementId\nlet foundReportId = null;\nfor (const [id, measurementIds] of Object.entries(reportLinks)) {\n    if (measurementIds.includes(measurementId)) {\n        foundReportId = Number(id); // Ensure report_id is returned as a number\n        break;\n    }\n}\n\n// Update the measurement with the found report_id or log an error\nif (foundReportId) {\n    new_measurement.report_id = foundReportId;\n    msg.payload.subreport_id = foundReportId;\n    node.warn(`Measurement ID ${measurementId} belongs to Report ID ${foundReportId}`);\n} else {\n    msg.payload.error = `Measurement ID ${measurementId} not found in any report.`;\n    node.warn(`Measurement ID ${measurementId} not found.`);\n}\n\n// Retrieve or initialize the all_measurements array in the flow context\nlet all_measurements = flow.get(\"all_measurements\") || [];\n\n// Check for duplicates before adding the new measurement\nlet isDuplicate = all_measurements.some(\n    measurement =>\n        measurement.m_unique_id === new_measurement.m_unique_id &&\n        measurement.subreport_id === new_measurement.subreport_id\n);\n\nif (!isDuplicate) {\n    all_measurements.push(new_measurement);\n    flow.set(\"all_measurements\", all_measurements);\n    node.warn(`Added new measurement: ${JSON.stringify(new_measurement, null, 2)}`);\n} else {\n    node.warn(`Duplicate measurement detected. Skipping addition: ${JSON.stringify(new_measurement, null, 2)}`);\n}\n\n// Return the message object\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 830,
        "y": 320,
        "wires": [
            []
        ]
    },
    {
        "id": "18826b373af39421",
        "type": "function",
        "z": "4ec0a7f75863202f",
        "name": "INSERT measurement",
        "func": "// Ensure msg.payload contains the necessary data\nif (!msg.payload || typeof msg.payload !== \"object\") {\n    node.error(\"Invalid input: msg.payload must be an object.\");\n    return null;\n}\n\n// Extract measurement object from msg.payload\nvar measurement = msg.payload;\n\n// Validate required fields\nif (\n    measurement.m_unique_id === undefined ||\n    measurement.time_stamp === undefined ||\n    measurement.name === undefined ||\n    measurement.subreport_id === undefined\n) {\n    node.error(\"Invalid input: msg.payload must contain all required fields (m_unique_id, time_stamp, name, subreport_id).\");\n    return null;\n}\n\n// Escape string values to prevent SQL injection\nfunction escapeString(str) {\n    return str.replace(/'/g, \"''\");\n}\n\n// Construct the SQL query with proper handling of null values\nvar topic = `\n    INSERT INTO Measurement (\n        m_unique_id, timestamp, name, mode, phase_name, load_type, step_id, \n        load_percentage, steady_state_voltage_tol, voltage_dc_component, \n        load_pf_deviation, switch_time_ms, run_interval_sec, backup_time_sec, \n        overload_time_sec, temperature_1, temperature_2, test_report_id\n    ) VALUES (\n        ${measurement.m_unique_id}, \n        datetime(${measurement.time_stamp} / 1000, 'unixepoch'), \n        '${escapeString(measurement.name)}', \n        ${measurement.mode ? `'${escapeString(measurement.mode)}'` : 'NULL'}, \n        ${measurement.phase_name ? `'${escapeString(measurement.phase_name)}'` : 'NULL'}, \n        ${measurement.load_type ? `'${escapeString(measurement.load_type)}'` : 'NULL'}, \n        ${measurement.step_id !== undefined ? measurement.step_id : 'NULL'}, \n        ${measurement.load_percentage !== undefined ? measurement.load_percentage : 'NULL'}, \n        ${measurement.steady_state_voltage_tol !== undefined ? measurement.steady_state_voltage_tol : 'NULL'}, \n        ${measurement.voltage_dc_component !== undefined ? measurement.voltage_dc_component : 'NULL'}, \n        ${measurement.load_pf_deviation !== undefined ? measurement.load_pf_deviation : 'NULL'}, \n        ${measurement.switch_time_ms !== undefined ? measurement.switch_time_ms : 'NULL'}, \n        ${measurement.run_interval_sec !== undefined ? measurement.run_interval_sec : 'NULL'}, \n        ${measurement.backup_time_sec !== undefined ? measurement.backup_time_sec : 'NULL'}, \n        ${measurement.overload_time_sec !== undefined ? measurement.overload_time_sec : 'NULL'}, \n        ${measurement.temperature_1 !== undefined ? measurement.temperature_1 : 'NULL'}, \n        ${measurement.temperature_2 !== undefined ? measurement.temperature_2 : 'NULL'}, \n        ${measurement.subreport_id}\n    );\n`;\n\n// Return the query to be executed by the SQLite node\nreturn { topic: topic };\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 430,
        "y": 620,
        "wires": [
            [
                "5f1f3198bcee0d63"
            ]
        ]
    },
    {
        "id": "5f1f3198bcee0d63",
        "type": "sqlite",
        "z": "4ec0a7f75863202f",
        "mydb": "0d4c44b815a8faab",
        "sqlquery": "msg.topic",
        "sql": "",
        "name": "MAIN_DB",
        "x": 610,
        "y": 620,
        "wires": [
            [
                "0e1b7fd7829d8533"
            ]
        ]
    },
    {
        "id": "0e1b7fd7829d8533",
        "type": "function",
        "z": "4ec0a7f75863202f",
        "name": "get measurement id",
        "func": "msg.topic=\"SELECT last_insert_rowid()\";\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 790,
        "y": 620,
        "wires": [
            [
                "cb6be12251a7102f"
            ]
        ]
    },
    {
        "id": "cb6be12251a7102f",
        "type": "sqlite",
        "z": "4ec0a7f75863202f",
        "mydb": "0d4c44b815a8faab",
        "sqlquery": "msg.topic",
        "sql": "",
        "name": "MAIN_DB",
        "x": 970,
        "y": 620,
        "wires": [
            [
                "1a31d7bd6a90d2d8"
            ]
        ]
    },
    {
        "id": "1a31d7bd6a90d2d8",
        "type": "function",
        "z": "4ec0a7f75863202f",
        "name": "save measurement id",
        "func": "// Ensure msg.payload contains the ID from the query result\nif (!msg.payload || !msg.payload[0] || !msg.payload[0]['last_insert_rowid()']) {\n    node.error(\"Invalid input: msg.payload must contain the result of last_insert_rowid().\");\n    return null;\n}\n\n// Extract the last inserted row ID\nlet lastInsertId = msg.payload[0]['last_insert_rowid()'];\n\n// Retrieve the existing array from flow context or initialize it\nlet allMeasurementIds = flow.get(\"all_measurement_id\") || [];\n\n// Add the new ID to the array\nallMeasurementIds.push(lastInsertId);\n\n// Save the updated array back to the flow context\nflow.set(\"all_measurement_id\", allMeasurementIds);\n\n// Log the updated array for debugging (optional)\nnode.warn(`Updated all_measurement_id: ${JSON.stringify(allMeasurementIds)}`);\nreturn msg;\n\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1150,
        "y": 620,
        "wires": [
            [
                "35db5fecab113913"
            ]
        ]
    },
    {
        "id": "754de0d72315e873",
        "type": "function",
        "z": "4ec0a7f75863202f",
        "name": "SAVE GLOBAL REPORT ID_SUB REPORT_ID AND REPORT",
        "func": "let rest_report=msg.payload;\n\n\nlet settings=rest_report.settings;\nflow.set(\"latest_report_id\",settings.report_id||0);\nflow.set(\"latest_subreport_id\",rest_report.subreport_id||0);\nflow.set(\"latest_report\",rest_report);\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 650,
        "y": 140,
        "wires": [
            [
                "5de1707360de3ca3"
            ]
        ]
    },
    {
        "id": "7126aec203523eaf",
        "type": "change",
        "z": "4ec0a7f75863202f",
        "name": "",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "latest_subreport_id",
                "tot": "flow"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 330,
        "y": 540,
        "wires": [
            [
                "8234f43a6332c074",
                "d56511342a6aa80d"
            ]
        ]
    },
    {
        "id": "8234f43a6332c074",
        "type": "debug",
        "z": "4ec0a7f75863202f",
        "name": "latest_report_id",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 590,
        "y": 540,
        "wires": []
    },
    {
        "id": "32965671a41e135c",
        "type": "switch",
        "z": "4ec0a7f75863202f",
        "name": "",
        "property": "payload",
        "propertyType": "msg",
        "rules": [
            {
                "t": "false"
            },
            {
                "t": "true"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 160,
        "y": 540,
        "wires": [
            [],
            [
                "7126aec203523eaf"
            ]
        ]
    },
    {
        "id": "d56511342a6aa80d",
        "type": "function",
        "z": "4ec0a7f75863202f",
        "name": "FETCH MEASUREMENTS",
        "func": "// Helper function for delaying execution\nfunction delay(ms) {\n    return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n// Retrieve all measurements from flow context\nlet all_measurements = flow.get(\"all_measurements\") || [];\nnode.warn(`Retrieved all_measurements: ${JSON.stringify(all_measurements, null, 2)}`);\n\n// Get the desired report_id from the incoming message\nlet subreport_id = msg.payload;\nif (subreport_id === undefined || subreport_id === null) {\n    node.error(\"Invalid subreport_id: undefined or null\", msg);\n    return null;\n}\n\n// Filter measurements for the given report_id\nlet filteredMeasurements = all_measurements.filter(m => m.report_id === subreport_id);\n\nif (filteredMeasurements.length === 0) {\n    node.warn(`No measurements found for report_id: ${subreport_id}`);\n    return null;\n}\n\n// Async function to send measurements one by one\nasync function sendMeasurements(measurements, send, done) {\n    for (let measurement of measurements) {\n        send({ payload: measurement }); // Send each measurement\n        await delay(1000); // 1-second delay between each message\n    }\n    done(); // Indicate processing is complete\n}\n\n// Start sending measurements asynchronously\nsendMeasurements(filteredMeasurements, node.send, () => node.done());\n\n// Return null as the function sends messages asynchronously\nreturn null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 190,
        "y": 620,
        "wires": [
            [
                "18826b373af39421"
            ]
        ]
    },
    {
        "id": "bc8e9479fde69e7d",
        "type": "ui-led",
        "z": "4ec0a7f75863202f",
        "name": "DATA Processed",
        "group": "ac18f679c10f1fd0",
        "order": 3,
        "width": 0,
        "height": 0,
        "label": "DATA Processed",
        "labelPlacement": "left",
        "labelAlignment": "left",
        "states": [
            {
                "value": "false",
                "valueType": "bool",
                "color": "#ff0000"
            },
            {
                "value": "true",
                "valueType": "bool",
                "color": "#00ff00"
            }
        ],
        "allowColorForValueInMessage": false,
        "shape": "circle",
        "showBorder": true,
        "showGlow": true,
        "x": 770,
        "y": 360,
        "wires": []
    },
    {
        "id": "934392df93190d41",
        "type": "link out",
        "z": "4ec0a7f75863202f",
        "name": "process_complete_out",
        "mode": "link",
        "links": [
            "6280dae54e650fe6"
        ],
        "x": 695,
        "y": 400,
        "wires": []
    },
    {
        "id": "6280dae54e650fe6",
        "type": "link in",
        "z": "4ec0a7f75863202f",
        "name": "process_complete_in",
        "links": [
            "934392df93190d41"
        ],
        "x": 55,
        "y": 540,
        "wires": [
            [
                "32965671a41e135c"
            ]
        ]
    },
    {
        "id": "35db5fecab113913",
        "type": "function",
        "z": "4ec0a7f75863202f",
        "name": "watch dog",
        "func": "// Get the timestamp of the last update\nlet lastUpdateTime = flow.get(\"last_update_time\") || 0;\n\n// Update the timestamp to the current time\nlet currentTime = Date.now();\nflow.set(\"last_update_time\", currentTime);\n\n// Initialize the watchdog timeout (in milliseconds)\nlet timeoutDuration = 3000; // 3 seconds (adjust as needed)\n\n// Clear any existing timeout\nlet watchdogTimer = flow.get(\"watchdog_timer\");\nif (watchdogTimer) {\n    clearTimeout(watchdogTimer);\n}\n\n// Set a new timeout to check if updates have stopped\nwatchdogTimer = setTimeout(() => {\n    // Check the current timestamp\n    let lastUpdate = flow.get(\"last_update_time\") || 0;\n    let now = Date.now();\n\n    // If no updates occurred within the timeout duration, send a \"true\" payload\n    if (now - lastUpdate >= timeoutDuration) {\n        node.send({ payload: true });\n    }\n}, timeoutDuration);\n\n// Store the new timeout in flow context\nflow.set(\"watchdog_timer\", watchdogTimer);\n\n// Send a \"false\" payload when updates are ongoing\nreturn { payload: false };\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 160,
        "y": 680,
        "wires": [
            [
                "9e2edbf349151202",
                "59c3b5b515ebf47b"
            ]
        ]
    },
    {
        "id": "9e2edbf349151202",
        "type": "ui-led",
        "z": "4ec0a7f75863202f",
        "name": "DB Measurement",
        "group": "ac18f679c10f1fd0",
        "order": 5,
        "width": 0,
        "height": 0,
        "label": "DB Measurement",
        "labelPlacement": "left",
        "labelAlignment": "left",
        "states": [
            {
                "value": "false",
                "valueType": "bool",
                "color": "#ff0000"
            },
            {
                "value": "true",
                "valueType": "bool",
                "color": "#00ff00"
            }
        ],
        "allowColorForValueInMessage": false,
        "shape": "circle",
        "showBorder": true,
        "showGlow": true,
        "x": 690,
        "y": 680,
        "wires": []
    },
    {
        "id": "964cf7e05606d27a",
        "type": "function",
        "z": "4ec0a7f75863202f",
        "name": "fetch powers",
        "func": "// Retrieve all_power_data from flow context\nconst allPowerData = flow.get(\"all_power_data\");\n\nif (!allPowerData || !Array.isArray(allPowerData)) {\n    node.warn(\"No power data available or data is not an array.\");\n    return null;\n}\n\n// Function to send data one by one with a delay\nasync function sendDataWithDelay(dataArray) {\n    for (const item of dataArray) {\n        node.send({ payload: item }); // Send the data\n        await new Promise(resolve => setTimeout(resolve, 1000)); // 1-second delay\n    }\n}\n\n// Start the async process\nsendDataWithDelay(allPowerData)\n    .then(() => node.done()) // Mark node as done after sending all data\n    .catch(err => node.error(\"Error sending data: \" + err));\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 110,
        "y": 840,
        "wires": [
            [
                "20450f4f7a43a947"
            ]
        ]
    },
    {
        "id": "a78403635e03631e",
        "type": "function",
        "z": "4ec0a7f75863202f",
        "name": "watch dog",
        "func": "// Get the timestamp of the last update\nlet lastUpdateTime = flow.get(\"last_update_time\") || 0;\n\n// Update the timestamp to the current time\nlet currentTime = Date.now();\nflow.set(\"last_update_time\", currentTime);\n\n// Initialize the watchdog timeout (in milliseconds)\nlet timeoutDuration = 3000; // 3 seconds (adjust as needed)\n\n// Clear any existing timeout\nlet watchdogTimer = flow.get(\"watchdog_timer\");\nif (watchdogTimer) {\n    clearTimeout(watchdogTimer);\n}\n\n// Set a new timeout to check if updates have stopped\nwatchdogTimer = setTimeout(() => {\n    // Check the current timestamp\n    let lastUpdate = flow.get(\"last_update_time\") || 0;\n    let now = Date.now();\n\n    // If no updates occurred within the timeout duration, send a \"true\" payload\n    if (now - lastUpdate >= timeoutDuration) {\n        node.send({ payload: true });\n    }\n}, timeoutDuration);\n\n// Store the new timeout in flow context\nflow.set(\"watchdog_timer\", watchdogTimer);\n\n// Send a \"false\" payload when updates are ongoing\nreturn { payload: false };\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1210,
        "y": 900,
        "wires": [
            [
                "c7407683108bb297",
                "66805343908213ee"
            ]
        ]
    },
    {
        "id": "c7407683108bb297",
        "type": "ui-led",
        "z": "4ec0a7f75863202f",
        "name": "DB Power",
        "group": "ac18f679c10f1fd0",
        "order": 6,
        "width": 0,
        "height": 0,
        "label": "DB Powers",
        "labelPlacement": "left",
        "labelAlignment": "left",
        "states": [
            {
                "value": "false",
                "valueType": "bool",
                "color": "#ff0000"
            },
            {
                "value": "true",
                "valueType": "bool",
                "color": "#00ff00"
            }
        ],
        "allowColorForValueInMessage": false,
        "shape": "circle",
        "showBorder": true,
        "showGlow": true,
        "x": 1380,
        "y": 900,
        "wires": []
    },
    {
        "id": "59c3b5b515ebf47b",
        "type": "switch",
        "z": "4ec0a7f75863202f",
        "name": "",
        "property": "payload",
        "propertyType": "msg",
        "rules": [
            {
                "t": "false"
            },
            {
                "t": "true"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 150,
        "y": 760,
        "wires": [
            [],
            [
                "964cf7e05606d27a"
            ]
        ]
    },
    {
        "id": "417ec4018e3df706",
        "type": "link in",
        "z": "4ec0a7f75863202f",
        "name": "backup_test_reset_in",
        "links": [
            "62eb936d918d3302"
        ],
        "x": 455,
        "y": 360,
        "wires": [
            [
                "bc8e9479fde69e7d"
            ]
        ]
    },
    {
        "id": "2498d1acf7fb0c00",
        "type": "link in",
        "z": "4ec0a7f75863202f",
        "name": "backup_test_reset_in2",
        "links": [
            "62eb936d918d3302"
        ],
        "x": 355,
        "y": 760,
        "wires": [
            [
                "9e2edbf349151202"
            ]
        ]
    },
    {
        "id": "3bb33a88dfacf747",
        "type": "link in",
        "z": "4ec0a7f75863202f",
        "name": "backup_test_reset3",
        "links": [
            "62eb936d918d3302"
        ],
        "x": 1215,
        "y": 940,
        "wires": [
            [
                "c7407683108bb297",
                "9e8152aa906f4172"
            ]
        ]
    },
    {
        "id": "5de1707360de3ca3",
        "type": "debug",
        "z": "4ec0a7f75863202f",
        "name": "report",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1030,
        "y": 140,
        "wires": []
    },
    {
        "id": "ed0573ddae590b22",
        "type": "debug",
        "z": "4ec0a7f75863202f",
        "name": "measurements",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1040,
        "y": 100,
        "wires": []
    },
    {
        "id": "8377d01d949c7ab9",
        "type": "function",
        "z": "4ec0a7f75863202f",
        "name": "fetch and insert_rest report",
        "func": "\n// Extract the rest_report object from msg.payload\nlet rest_report = flow.get(\"latest_report\");\n\n// Validate required fields\nif (\n    !rest_report.settings ||\n    !rest_report.test_name ||\n    typeof rest_report.test_name !== \"string\"\n) {\n    node.error(\"Invalid input: rest_report must contain 'settings' and 'test_name'.\");\n    return null;\n}\n\n// Optional fields\nlet test_description = rest_report.test_description || null;\nlet test_result = rest_report.test_result || null;\n\n// Construct the SQL query\nlet topic = `\n    INSERT INTO TestReport (settings_id,sub_report_id, test_name, test_description, test_result)\n    VALUES (\n        ${rest_report.settings.id}, \n        ${rest_report.subreport_id}, \n        '${rest_report.test_name.replace(/'/g, \"''\")}', \n        ${test_description ? `'${test_description.replace(/'/g, \"''\")}'` : \"NULL\"},\n        ${test_result ? `'${test_result.replace(/'/g, \"''\")}'` : \"NULL\"}\n    );\n`;\n\n// Return the query to be executed by the SQLite node\nreturn { topic: topic };\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 260,
        "y": 1020,
        "wires": [
            [
                "5502c5c79a1b0122"
            ]
        ]
    },
    {
        "id": "5502c5c79a1b0122",
        "type": "sqlite",
        "z": "4ec0a7f75863202f",
        "mydb": "0d4c44b815a8faab",
        "sqlquery": "msg.topic",
        "sql": "",
        "name": "MAIN_DB",
        "x": 480,
        "y": 1020,
        "wires": [
            [
                "2efcccf1b6ca503a"
            ]
        ]
    },
    {
        "id": "2efcccf1b6ca503a",
        "type": "function",
        "z": "4ec0a7f75863202f",
        "name": "get report id",
        "func": "msg.topic=\"SELECT last_insert_rowid()\";\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 630,
        "y": 1020,
        "wires": [
            [
                "712f1790b2209428"
            ]
        ]
    },
    {
        "id": "712f1790b2209428",
        "type": "sqlite",
        "z": "4ec0a7f75863202f",
        "mydb": "0d4c44b815a8faab",
        "sqlquery": "msg.topic",
        "sql": "",
        "name": "MAIN_DB",
        "x": 800,
        "y": 1020,
        "wires": [
            [
                "751ce3614ab124c4"
            ]
        ]
    },
    {
        "id": "751ce3614ab124c4",
        "type": "function",
        "z": "4ec0a7f75863202f",
        "name": "save test report",
        "func": "// Ensure msg.payload contains the ID from the query result\nif (!msg.payload || !msg.payload[0] || !msg.payload[0]['last_insert_rowid()']) {\n    node.error(\"Invalid input: msg.payload must contain the result of last_insert_rowid().\");\n    return null;\n}\n\n// Extract the last inserted row ID\nlet lastInsertId = msg.payload[0]['last_insert_rowid()'];\n\n// Retrieve the existing array from flow context or initialize it\nlet allTestReportIds = flow.get(\"all_test_report_id\") || [];\n\n// Add the new ID to the array\nallTestReportIds.push(lastInsertId);\n\n// Save the updated array back to the flow context\nflow.set(\"all_test_report_id\", allTestReportIds);\n\n// Log the updated array for debugging (optional)\nnode.warn(`Updated all_test_report_id: ${JSON.stringify(allTestReportIds)}`);\n\n// Pass through the message for further processing\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 960,
        "y": 1020,
        "wires": [
            [
                "29bfe566133d163a"
            ]
        ]
    },
    {
        "id": "29bfe566133d163a",
        "type": "function",
        "z": "4ec0a7f75863202f",
        "name": "watch dog",
        "func": "// Get the timestamp of the last update\nlet lastUpdateTime = flow.get(\"last_update_time\") || 0;\n\n// Update the timestamp to the current time\nlet currentTime = Date.now();\nflow.set(\"last_update_time\", currentTime);\n\n// Initialize the watchdog timeout (in milliseconds)\nlet timeoutDuration = 1000; // 3 seconds (adjust as needed)\n\n// Clear any existing timeout\nlet watchdogTimer = flow.get(\"watchdog_timer\");\nif (watchdogTimer) {\n    clearTimeout(watchdogTimer);\n}\n\n// Set a new timeout to check if updates have stopped\nwatchdogTimer = setTimeout(() => {\n    // Check the current timestamp\n    let lastUpdate = flow.get(\"last_update_time\") || 0;\n    let now = Date.now();\n\n    // If no updates occurred within the timeout duration, send a \"true\" payload\n    if (now - lastUpdate >= timeoutDuration) {\n        node.send({ payload: true });\n    }\n}, timeoutDuration);\n\n// Store the new timeout in flow context\nflow.set(\"watchdog_timer\", watchdogTimer);\n\n// Send a \"false\" payload when updates are ongoing\nreturn { payload: false };\n\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1150,
        "y": 1020,
        "wires": [
            [
                "9e8152aa906f4172"
            ]
        ]
    },
    {
        "id": "9e8152aa906f4172",
        "type": "ui-led",
        "z": "4ec0a7f75863202f",
        "name": "DB REPORT",
        "group": "ac18f679c10f1fd0",
        "order": 7,
        "width": 0,
        "height": 0,
        "label": "DB REPORT",
        "labelPlacement": "left",
        "labelAlignment": "left",
        "states": [
            {
                "value": "false",
                "valueType": "bool",
                "color": "#ff0000"
            },
            {
                "value": "true",
                "valueType": "bool",
                "color": "#00ff00"
            }
        ],
        "allowColorForValueInMessage": false,
        "shape": "circle",
        "showBorder": true,
        "showGlow": true,
        "x": 1390,
        "y": 1020,
        "wires": []
    },
    {
        "id": "ef1c0aa150a88ea5",
        "type": "debug",
        "z": "4ec0a7f75863202f",
        "name": "debug 8",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 480,
        "y": 180,
        "wires": []
    },
    {
        "id": "66805343908213ee",
        "type": "switch",
        "z": "4ec0a7f75863202f",
        "name": "",
        "property": "payload",
        "propertyType": "msg",
        "rules": [
            {
                "t": "false"
            },
            {
                "t": "true"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 2,
        "x": 150,
        "y": 960,
        "wires": [
            [],
            [
                "8377d01d949c7ab9"
            ]
        ]
    },
    {
        "id": "0d4c44b815a8faab",
        "type": "sqlitedb",
        "db": "D:\\_0_DEV_SOFTWARE\\PIO_ESPIDF\\UPS_TESTER_PROJECT\\powerGuard\\db\\test_reports.db",
        "mode": "RWC"
    },
    {
        "id": "ac18f679c10f1fd0",
        "type": "ui-group",
        "name": "UPS_STATUS",
        "page": "7d0f53039d1540b1",
        "width": 3,
        "height": "1",
        "order": 1,
        "showTitle": true,
        "className": "",
        "visible": "true",
        "disabled": "false",
        "groupType": "default"
    },
    {
        "id": "7d0f53039d1540b1",
        "type": "ui-page",
        "name": "BACKUP_TEST",
        "ui": "6bb6879aa70631ea",
        "path": "/backup_test",
        "icon": "battery-clock",
        "layout": "grid",
        "theme": "f51f9a07212ff54b",
        "breakpoints": [
            {
                "name": "Default",
                "px": "0",
                "cols": "3"
            },
            {
                "name": "Tablet",
                "px": "576",
                "cols": "6"
            },
            {
                "name": "Small Desktop",
                "px": "768",
                "cols": "9"
            },
            {
                "name": "Desktop",
                "px": "1024",
                "cols": "12"
            }
        ],
        "order": 2,
        "className": "",
        "visible": "true",
        "disabled": "false"
    },
    {
        "id": "6bb6879aa70631ea",
        "type": "ui-base",
        "name": "UPS Tester",
        "path": "/dashboard",
        "appIcon": "",
        "includeClientData": true,
        "acceptsClientConfig": [
            "ui-notification",
            "ui-control"
        ],
        "showPathInSidebar": false,
        "showPageTitle": true,
        "navigationStyle": "default",
        "titleBarStyle": "default",
        "showReconnectNotification": true,
        "notificationDisplayTime": "1",
        "showDisconnectNotification": true
    },
    {
        "id": "f51f9a07212ff54b",
        "type": "ui-theme",
        "name": "Default Theme",
        "colors": {
            "surface": "#d1479f",
            "primary": "#0094ce",
            "bgPage": "#ededed",
            "groupBg": "#ffffff",
            "groupOutline": "#cccccc"
        },
        "sizes": {
            "density": "default",
            "pagePadding": "12px",
            "groupGap": "12px",
            "groupBorderRadius": "4px",
            "widgetGap": "12px"
        }
    }
]